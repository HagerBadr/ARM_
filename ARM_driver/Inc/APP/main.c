/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include "STD_TYPES.h"
#include "BIT_MATH.h"

#include "RCC_interface.h"
#include "GPIO_int.h"
#include "EXTI_int.h"
#include "NVIC_int.h"
#include "SSD_int.h"
#include "Heater_interface.h"
#include "Cooler_interface.h"
#include "SSD_int.h"
#include "ADC_int.h"
#include "STK_int.h"


typedef enum
{
	OFF_STATE,
	NORMAL_MODE_STATE,
	SETTING_MODE_STATE
}State_t;
State_t state = OFF_STATE;
u8 TEMP_Ref_value = 35; /* Setting Mode */
u8 TEMP_Current_value = 53; /* Normal Mode */
u8 flag_down = 0;
u8 flag_up = 0;

void SwitchToNormal(void)
{
	state = NORMAL_MODE_STATE;
}
void TEMP_down(void)
{
	flag_down = 1;
	state = SETTING_MODE_STATE;

}
void TEMP_up(void)
{
	flag_up = 1;
	state = SETTING_MODE_STATE;

}
void EXIT_setting_mode(void)
{
	state = NORMAL_MODE_STATE;
}
int main(void)
{
	EXTI_PinConfig_t Local_EXTI0 = {EXTI_u8_PORTA,PIN1,EXTI_u8_FALLING_EDGE,SwitchToNormal};
	EXTI_PinConfig_t Local_EXTI1 = {EXTI_u8_PORTA,PIN2,EXTI_u8_FALLING_EDGE,TEMP_down};
	EXTI_PinConfig_t Local_EXTI2 = {EXTI_u8_PORTA,PIN3,EXTI_u8_FALLING_EDGE,TEMP_up};
	/* RCC Initialize */
	MRCC_voidSysClkInit();
	/* GPIOA Enable Clock */
	MRCC_voidEnablePerClk(RCC_APB2,DIO_A);
	/* GPIOC Enable Clock */
	MRCC_voidEnablePerClk(RCC_APB2,DIO_C);
	MRCC_voidEnablePerClk(RCC_APB2,0);
	/* Init SSD */
	H_SSD_Void_init();
	/* Init HEATER & COOLER */
	H_HEATER_void_init();
	H_COOLER_void_init();
	/* Init STK */
	STK_voidInit();
		// Set ADC Prescaler
	MRCC_voidSetADCPre(RCC_ADC_PRE_2);
	// Enable Per Clk "RCC" -> ADC -> 9
	MRCC_voidEnablePerClk(RCC_APB2,9);
	// Set Direction for ADC channel_0 as IN_ANALOG
	M_GPIO_void_SetPinDir(PORTA, PIN0, IN_ANALOG);
	/* Init ADC */
	ADC_void_init();

	/* IO Pins Initialization */
	M_GPIO_void_SetPinDir(PORTA,PIN1,IN_PULL_UP_DOWN); /* A0 Input Floating        */
	M_DIO_void_setPinVal(PORTA,PIN1,DIO_HIGH);
	M_GPIO_void_SetPinDir(PORTA,PIN2,IN_PULL_UP_DOWN); /* A1 Input Floating        */
	M_DIO_void_setPinVal(PORTA,PIN2,DIO_HIGH);
	M_GPIO_void_SetPinDir(PORTA,PIN3,IN_PULL_UP_DOWN); /* A2 Input Floating        */
	M_DIO_void_setPinVal(PORTA,PIN3,DIO_HIGH);

	M_GPIO_void_SetPinDir(PORTC,PIN14,OUT_2MHZ_PP); /* C14 Output        */
	M_GPIO_void_SetPinDir(PORTC,PIN15,OUT_2MHZ_PP); /* C15 Output        */
	M_DIO_void_setPinVal(PORTC,PIN14,DIO_HIGH);
	M_DIO_void_setPinVal(PORTC,PIN15,DIO_HIGH);



	/* EXTI Initializtion */
	EXTI_u8PinInit(&Local_EXTI0);
	EXTI_u8PinInit(&Local_EXTI1);
	EXTI_u8PinInit(&Local_EXTI2);
	EXTI_u8IntEnable(&Local_EXTI0);
	EXTI_u8IntEnable(&Local_EXTI1);
	EXTI_u8IntEnable(&Local_EXTI2);

	/* Enable EXTI0 from NVIC */
	NVIC_u8EnableInterrupt(7); /* EXTI0 */
	NVIC_u8EnableInterrupt(8); /* EXTI1 */
	NVIC_u8EnableInterrupt(9); /* EXTI2 */


	/* Loop forever */
	while(1)
	{
		switch(state)
		{
		case OFF_STATE:
			/* Disable Heater & Cooler & SSD*/
			H_HEATER_void_stop();
			H_COOLER_void_stop();
			H_SSD_Void_DisplayOFF();
			break;
		case NORMAL_MODE_STATE:
			/*
			TEMP_Current_value = ((ADC_u16_read(CHANNEL_0) * 8) / 100);
			H_SSD_Void_DisplayNumber(TEMP_Current_value);
			*/
			break;
		case SETTING_MODE_STATE:
			/* SET ref temp value */
			if( flag_up == 1)
			{
				if(TEMP_Ref_value < 75)
				{
					TEMP_Ref_value += 5;
				}
				flag_up = 0;
				STK_voidStopInterval();
				STK_voidSetIntervalSingle(5000000,EXIT_setting_mode);
			}
			else if(flag_down == 1)
			{
				if(TEMP_Ref_value > 35)
				{
					TEMP_Ref_value -= 5;
				}
				flag_down = 0;
				STK_voidStopInterval();
				STK_voidSetIntervalSingle(5000000,EXIT_setting_mode);
			}
			H_SSD_Void_DisplayNumber(TEMP_Ref_value);
			//_delay_ms(1000);
			H_SSD_Void_DisplayOFF();
			_delay_ms(260);
			break;
		default: break;
		}
	}

}
